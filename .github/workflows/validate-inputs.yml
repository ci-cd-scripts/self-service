name: Validate Inputs
# Read more on securing GitHub Action/Workflow inputs:
# https://securitylab.github.com/research/github-actions-untrusted-input/

on:
  # Allows you to reuse this workflow from other workflows
  workflow_call:
    inputs:
      repoName:
        description: 'Repository Name'
        required: true
        type: string  # Can be: [boolean,number,string]
      envName:
        description: 'Environment Name'
        required: true
        type: string
      templateRepo:
        description: 'Template repo to use'
        required: false
        type: string
      teams:
        description: 'Comma-separated list of team-slugs'
        required: true
        default: org-admin
        type: string
      enableIssue:
        description: 'Enable Repo Issues?'
        required: true
        type: string
      enableProject:
        description: 'Enable Repo Projects?'
        required: true
        type: string
      enableSquashMerge:
        description: 'Enable Repo Squash Merging?'
        required: true
        type: string
      enableForking:
        description: 'Enable Repo Forking?'
        required: true
        type: string
    secrets:
      caller-token:
        required: true

jobs:
  # debug is used to help validate job inputs & vars
  debug:
    runs-on: ubuntu-latest
    steps:
    - name: Dump GitHub context
      env:
        GITHUB_CONTEXT: ${{ toJson(github) }}
        GITHUB_INPUTS: ${{ toJson(inputs) }}
      run: |
        echo "GITHUB_CONTEXT:"
        echo "$GITHUB_CONTEXT"
        echo "GITHUB_INPUTS:"
        echo "$GITHUB_INPUTS"
    - name: Print workflow inputs
      run: |
        echo "repoName: [${{ inputs.repoName }}]"
        echo "env: [${{ inputs.envName }}]"
        echo "templateRepo: [${{ inputs.templateRepo }}]"
        echo "teams: [${{ inputs.teams }}]"
        echo "enableIssue: [${{ inputs.enableIssue }}]"
        echo "enableProject: [${{ inputs.enableProject }}]"
        echo "enableSquashMerge: [${{ inputs.enableSquashMerge }}]"
        echo "enableForking: [${{ inputs.enableForking }}]"

  validate-inputs:
    runs-on: ubuntu-latest
    environment: ${{ inputs.envName }}
    outputs:
      repoName:           ${{ steps.set-inputs.outputs.repoName }}
      envName:            ${{ steps.set-inputs.outputs.envName }}
      templateRepo:       ${{ steps.set-inputs.outputs.templateRepo }}
      teams:              ${{ steps.set-inputs.outputs.teams }}
      enableIssue:        ${{ steps.set-inputs.outputs.enableIssue }}
      enableProject:      ${{ steps.set-inputs.outputs.enableProject }}
      enableSquashMerge:  ${{ steps.set-inputs.outputs.enableSquashMerge }}
      enableForking:      ${{ steps.set-inputs.outputs.enableForking }}
    steps:
      - name: Validate & Format Inputs
        id: format-inputs
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.caller-token }}
          script: |
            // Set vars for this step
            let repoName = "${{ inputs.repoName }}"
            let templateRepo = "${{ inputs.templateRepo }}"
            let teams = "${{ inputs.teams }}".trim()
            let enableIssue = ${{ inputs.enableIssue }}
            let enableProject = ${{ inputs.enableProject }}
            let enableSquashMerge = ${{ inputs.enableSquashMerge }}
            let enableForking = ${{ inputs.enableForking }}
            let teamAccessOptions = ["admin", "maintain", "write", "triage", "read"]

            async function teamExists(teamSlug) {
              var exists = false
              await github.rest.teams.getByName({
                "org": context.payload.organization.login,
                "team_slug": teamSlug
              }).then((res) => {
                console.log(`Team [${teamSlug}] exists`)
                exists = true
              }).catch((err) => {
                console.log(`Team: [${teamSlug}] does not exist: ${err}`)
              })
              return exists
            }

            async function teamMember(teamSlug) {
              var member = false
              await github.rest.teams.getMembershipForUserInOrg({
                org: context.payload.organization.login,
                team_slug: teamSlug,
                username: context.payload.sender.login,
              }).then((res) => {
                console.log(`[${context.payload.sender.login}] is a member of the [${teamSlug}] team`)
                member = true
              }).catch((err) => {
                console.log(`Not a member of [${teamSlug}]: ${err}`)
              })
              return member
            }

            function teamSlugs(team) {
              var teamSlug = team.trim().replace(/\s+/g, '-').toLowerCase()
              if (teamAccessOptions.some(e => teamSlug.endsWith(e))) {
                return teamSlug
              } else {
                return teamAccessOptions.map(e => teamSlug + '-' + e);
              }
            }

            // FORMAT STANDARDIZED TEAM SLUGS
            const slugs = teams.split(",").filter(e => e.trim()).flatMap(e => teamSlugs(e))
            console.log(`Validating formatted team slugs: [${slugs}]`)

            // SENDER IS IN ADMIN TEAM
            var adminTeams = await Promise.all(slugs.filter(e => e.endsWith('-admin')).map(e => teamMember(e)))
            if (!adminTeams.some(e => e)) {
              core.setFailed(`User is not a member of any admin teams.`);
            } else {
              console.log(`User is a member of an admin team`)
            }

            // EACH TEAM EXISTS
            var existingTeams = await Promise.all(slugs.map(e => teamExists(e)))
            if (!existingTeams.every(e => e)) {
              core.setFailed(`Not all teams entered are valid`);
            } else {
              console.log("All teams entered exist")
              core.setOutput('repoName', repoName); // FORMATTED
              core.setOutput('envName', context.payload.organization.login);
              core.setOutput('templateRepo', templateRepo);
              core.setOutput('teams', slugs); // FORMATTED
              core.setOutput('enableIssue', enableIssue);
              core.setOutput('enableProject', enableProject);
              core.setOutput('enableSquashMerge', enableSquashMerge);
              core.setOutput('enableForking', enableForking);
            }